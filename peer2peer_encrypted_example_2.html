<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Peer-to-Peer Encrypted Messaging (Animated Demo)</title>
<style>
  :root { --bg:#fff; --fg:#000; --muted:#222; --accent:#0a0a0a; --card:#f4f4f4; --line:#ababab; }
  html, body { background:var(--bg); color:var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; margin:0; padding:0; }
  header, footer { max-width:1100px; margin:24px auto 12px; padding:0 16px; }
  header h1 { margin:0 0 8px; font-size:1.6rem; }
  header p { margin:0; line-height:1.45; }
  main { max-width:1100px; margin:12px auto 24px; padding:0 16px; }
  .grid { display:grid; grid-template-columns:1fr 260px 1fr; gap:16px; align-items:start; }
  .peer { background:var(--card); border:1px solid var(--line); border-radius:12px; padding:16px; }
  .peer h2 { margin:0 0 8px; font-size:1.2rem; }
  .peer .kblock { font:12px/1.35 ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace; white-space:pre-wrap; word-break:break-word; background:#fff; border:1px solid var(--line); border-radius:8px; padding:8px; max-height:160px; overflow:auto; }
  .wire { position:relative; height:200px; border:1px dashed var(--line); border-radius:12px; display:grid; place-items:center; overflow:hidden; background:#fff; }
  .wire .lane { position:absolute; top:50%; width:92%; height:2px; background:var(--line); transform:translateY(-50%); }
  .bubble { position:absolute; top:calc(50% - 18px); width:max(240px,32%); max-width:420px; transform:translateX(0); padding:10px 12px; background:#fff; border:1px solid var(--fg); border-radius:14px; box-shadow:0 1px 0 rgba(0,0,0,.06); font:12px/1.35 ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace; opacity:0; }
  .bubble small { display:block; color:#444; margin-bottom:4px; }
  .bubble.right { right:4%; }   /* moving left ← */
  .bubble.left  { left:4%; }    /* moving right → */
  @keyframes fly-right { 0%{transform:translateX(0);opacity:0;} 10%{opacity:1;} 90%{opacity:1;} 100%{transform:translateX(220%);opacity:0;} }
  @keyframes fly-left  { 0%{transform:translateX(0);opacity:0;} 10%{opacity:1;} 90%{opacity:1;} 100%{transform:translateX(-220%);opacity:0;} }
  .controls { display:flex; gap:8px; margin:16px 0; flex-wrap:wrap; }
  button { background:#fff; color:var(--fg); border:1px solid var(--fg); border-radius:10px; padding:10px 14px; cursor:pointer; font-weight:600; }
  button:disabled { opacity:.5; cursor:not-allowed; }
  .log { background:#fff; border:1px solid var(--line); border-radius:12px; padding:12px; max-height:220px; overflow:auto; font:12px/1.45 ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace; white-space:pre-wrap; }
  details { margin-top:10px; }
  .note { border-left:4px solid var(--line); padding-left:10px; font-size:.95rem; color:#111; }
  hr { border:none; border-top:1px solid var(--line); margin:24px 0; }
  .apa { font-size:.95rem; } .apa li{ margin-bottom:6px; }
</style>
</head>
<body>
<header>
  <h1>Encrypted Peer-to-Peer Messaging — Visual Walkthrough</h1>
  <p>This page simulates two peers deriving a shared key (ECDH), then sending messages protected with AES-GCM. While the “packet” crosses the wire, you will only see ciphertext; upon arrival it is decrypted and rendered as plaintext.</p>
</header>

<main>
  <div class="controls">
    <button id="runBtn">▶ Run Demo</button>
    <button id="resetBtn" disabled>↺ Reset</button>
  </div>

  <section class="grid">
    <div class="peer" id="peerA">
      <h2>Peer A</h2>
      <div><strong>EC Key (P-256):</strong></div>
      <div class="kblock" id="aKeys">—</div>
      <details>
        <summary>Derived Session Key (AES-GCM)</summary>
        <div class="kblock" id="aKeyInfo">—</div>
      </details>
    </div>

    <div class="wire">
      <div class="lane" aria-hidden="true"></div>
      <div class="bubble left" id="bubbleA">
        <small>in transit (ciphertext)</small>
        <span id="cipherA">…</span>
      </div>
      <div class="bubble right" id="bubbleB">
        <small>in transit (ciphertext)</small>
        <span id="cipherB">…</span>
      </div>
    </div>

    <div class="peer" id="peerB">
      <h2>Peer B</h2>
      <div><strong>EC Key (P-256):</strong></div>
      <div class="kblock" id="bKeys">—</div>
      <details>
        <summary>Derived Session Key (AES-GCM)</summary>
        <div class="kblock" id="bKeyInfo">—</div>
      </details>
    </div>
  </section>

  <h3>Connection & Crypto Log</h3>
  <div class="log" id="log">Ready.</div>

  <details class="note">
    <summary>What is happening (conceptually)?</summary>
    <p><strong>1) Key Agreement (ECDH):</strong> Each peer creates an ephemeral EC key pair and exchanges only its public key. Using Elliptic-Curve Diffie–Hellman, both derive the same shared secret and from that a symmetric session key.</p>
    <p><strong>2) Authenticated Encryption (AES-GCM):</strong> Messages are sealed using AES in Galois/Counter Mode (AEAD). Each message uses a fresh 96-bit IV/nonce.</p>
    <p><strong>3) Transit vs. Endpoints:</strong> The “wire” only carries ciphertext. Each endpoint shows the original plaintext only after successful decryption and authentication.</p>
  </details>

  <hr />

  <section>
    <h3>References (APA)</h3>
    <ol class="apa">
      <li>Mozilla. (2025). <em>SubtleCrypto — Web Crypto API</em>. MDN Web Docs.</li>
      <li>Dworkin, M. (2007). <em>NIST SP 800-38D: GCM and GMAC</em>. NIST.</li>
      <li>McGrew, D. (2008). <em>RFC 5116: Authenticated Encryption</em>. RFC Editor.</li>
      <li>Rescorla, E. (2018). <em>RFC 8446: TLS 1.3</em>. RFC Editor.</li>
    </ol>
  </section>
</main>

<footer><small>Demo only. Not production crypto.</small></footer>

<script>
/* ============================== Utilities ============================== */
const $ = s => document.querySelector(s);
const logEl = $("#log");
const enc = new TextEncoder();
const dec = new TextDecoder();
const toHex = buf => Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,"0")).join("");
const toB64 = buf => btoa(String.fromCharCode(...new Uint8Array(buf)));
function log(line){ const ts=new Date().toLocaleTimeString(); logEl.textContent += `\\n[${ts}] ${line}`; logEl.scrollTop = logEl.scrollHeight; }

/* ============================== Peer state ============================ */
let peers = {
  A: { kp:null, aesKey:null },
  B: { kp:null, aesKey:null }
};

/* ============================== Crypto helpers ======================== */
async function genEcdhKeyPair(){
  return crypto.subtle.generateKey({ name:"ECDH", namedCurve:"P-256" }, true, ["deriveKey","deriveBits"]);
}
async function exportJwkPublic(key){ return crypto.subtle.exportKey("jwk", key); }
async function deriveAesGcm(myPriv, theirPub){
  return crypto.subtle.deriveKey({ name:"ECDH", public: theirPub }, myPriv, { name:"AES-GCM", length:256 }, true, ["encrypt","decrypt"]);
}
async function aesGcmEncrypt(k, text){
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ct = await crypto.subtle.encrypt({ name:"AES-GCM", iv }, k, enc.encode(text));
  return { iv, ct };
}
async function aesGcmDecrypt(k, iv, ct){
  const pt = await crypto.subtle.decrypt({ name:"AES-GCM", iv }, k, ct);
  return dec.decode(pt);
}

async function keyThumbprint(aesKey){
  const raw = await crypto.subtle.exportKey("raw", aesKey);
  const hash = await crypto.subtle.digest("SHA-256", raw);
  return toHex(hash).slice(0,16);
}

/* ============================== UI helpers ============================ */
async function showKeys(){
  const ajwk = peers.A.kp ? await exportJwkPublic(peers.A.kp.publicKey) : null;
  const bjwk = peers.B.kp ? await exportJwkPublic(peers.B.kp.publicKey) : null;
  $("#aKeys").textContent = ajwk ? JSON.stringify(ajwk, null, 2) : "—";
  $("#bKeys").textContent = bjwk ? JSON.stringify(bjwk, null, 2) : "—";
}
async function showSessionKeys(){
  $("#aKeyInfo").textContent = peers.A.aesKey ? `AES-256-GCM\\nthumb: ${await keyThumbprint(peers.A.aesKey)}` : "—";
  $("#bKeyInfo").textContent = peers.B.aesKey ? `AES-256-GCM\\nthumb: ${await keyThumbprint(peers.B.aesKey)}` : "—";
}
function animateBubble(dir, label, b64, ms=2000){
  const bubble = dir==="AtoB" ? $("#bubbleA") : $("#bubbleB");
  const span   = dir==="AtoB" ? $("#cipherA") : $("#cipherB");
  bubble.style.opacity = 0;
  span.textContent = `${label}\\n${b64}`;
  bubble.style.animation = "none";
  void bubble.offsetWidth; // restart animation
  bubble.style.animation = `${dir==="AtoB"?"fly-right":"fly-left"} ${ms}ms ease-in-out 1 forwards`;
  bubble.style.opacity = 1;
  return new Promise(r=>setTimeout(r,ms));
}

/* ============================== Demo choreography ===================== */
async function runDemo(){
  $("#runBtn").disabled = true;
  $("#resetBtn").disabled = true;

  log("Generating ephemeral ECDH key pairs (P-256) for A and B…");
  peers.A.kp = await genEcdhKeyPair();
  peers.B.kp = await genEcdhKeyPair();
  await showKeys();

  log("Exchanging public keys (A ⇄ B) and deriving AES-256-GCM session key…");
  peers.A.aesKey = await deriveAesGcm(peers.A.kp.privateKey, peers.B.kp.publicKey);
  peers.B.aesKey = await deriveAesGcm(peers.B.kp.privateKey, peers.A.kp.publicKey);
  await showSessionKeys();

  // A -> B
  const msgA = "Hello, Peer B. (This is confidential.)";
  log("Peer A: encrypting message for B using AES-GCM (fresh IV) …");
  const { iv: ivA, ct: ctA } = await aesGcmEncrypt(peers.A.aesKey, msgA);
  await animateBubble("AtoB", `AES-GCM\\nIV=${toHex(ivA)}`, toB64(ctA), 2200);
  log("Peer B: received ciphertext. Attempting decryption …");
  const decA = await aesGcmDecrypt(peers.B.aesKey, ivA, ctA);
  log(`Peer B: ✅ decrypted: "${decA}"`);

  // B -> A
  const msgB = "Hello, Peer A. Reply received. Integrity verified.";
  log("Peer B: encrypting reply for A (fresh IV) …");
  const { iv: ivB, ct: ctB } = await aesGcmEncrypt(peers.B.aesKey, msgB);
  await animateBubble("BtoA", `AES-GCM\\nIV=${toHex(ivB)}`, toB64(ctB), 2200);
  log("Peer A: received ciphertext. Attempting decryption …");
  const decB = await aesGcmDecrypt(peers.A.aesKey, ivB, ctB);
  log(`Peer A: ✅ decrypted: "${decB}"`);

  log("Demo complete. You can reset and run again.");
  $("#resetBtn").disabled = false;
}

function resetDemo(){
  $("#runBtn").disabled = false;
  $("#resetBtn").disabled = true;
  logEl.textContent = "Ready.";
  $("#aKeys").textContent = "—"; $("#bKeys").textContent = "—";
  $("#aKeyInfo").textContent = "—"; $("#bKeyInfo").textContent = "—";
  $("#bubbleA").style.animation = "none"; $("#bubbleB").style.animation = "none";
  $("#bubbleA").style.opacity = 0; $("#bubbleB").style.opacity = 0;
  peers = { A:{kp:null,aesKey:null}, B:{kp:null,aesKey:null} };
}

/* ============================== Wire up buttons ======================= */
$("#runBtn").addEventListener("click", runDemo);
$("#resetBtn").addEventListener("click", resetDemo);
</script>
</body>
</html>
